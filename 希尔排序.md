**希尔排序**是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；
随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。

*希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，*

这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。

希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，
但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

假设原始数组arr数据如下：
![image](https://img-blog.csdnimg.cn/dcf168c360284ea4be16de5558e0c324.png)

初始增量gap=arr.length/2=8/2=4,意味着整个数组被分为4组，这四组分别使用插入排序如下:
![image](https://img-blog.csdnimg.cn/b6a4d3ebc180431dbd2eaa146ecb2f76.png)


继续进行增量排序gap=gap/2=4/2=2,,数组被重新分组为两组，对这两组使用插入排序继续进行排序
![image](https://img-blog.csdnimg.cn/f8f5a7d6ee124068af7694a3af0c6b6a.png)

直到增量排序gap=1时，将数组分为一组，数组无法再进行增量排序，则进行最后一次排序
![image](https://img-blog.csdnimg.cn/3acba3f19dee4a93a879c897d080f165.png)

具体详细代码如下：
//希尔排序
'''
void ShellSort(int* arr, int n)

{

	int gap = n;
  
	while (gap>1)
  
	{
  
		//每次对gap折半操作
    
		gap = gap / 2;
    
		//单趟排序
    
		for (int i = 0; i < n - gap; ++i)
    
		{
    
			int end = i;
      
			int tem = arr[end + gap];
      
			while (end >= 0)
      
			{
      
				if (tem < arr[end])
        
				{
        
					arr[end + gap] = arr[end];
          
					end -= gap;
          
				}
        
				else
        
				{
        
					break;
          
				}
        
			}
      
			arr[end + gap] = tem;
      
		}
    
	}
  
}

'''
